<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Local Stat Tracker</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;600;700&family=Work+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root { --pad: 12px; --font-body: 'Work Sans', system-ui, -apple-system, Arial, sans-serif; --font-head: 'Poppins', system-ui, -apple-system, Arial, sans-serif; }
  * { box-sizing: border-box; }
  body { font-family: var(--font-body); margin: var(--pad); }
  h2 { margin: 8px 0; }
  h2, h3, .name { font-family: var(--font-head); }

  /* Top bar: Undo/Redo + Save status */
  .topbar { display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
  .btn-md { padding:14px 18px; border:none; border-radius:12px; cursor:pointer; font-size:18px; font-weight:800; background:#f2f2f2; }
  .btn-sm { padding:10px 14px; border:none; border-radius:10px; cursor:pointer; font-size:14px; font-weight:700; background:#f2f2f2; }
  .btn-huddle { background: rgba(111, 66, 193, 0.18); color:#4b2a83; }
  .btn-disabled { opacity:0.5; pointer-events:none; }
  .spacer { flex:1 1 auto; }
  .muted { font-size:12px; color:#666; }

  /* Setup / Roster editor */
  .setup { border:1px solid #eee; border-radius:12px; padding:12px; margin-bottom:12px; background:#fafafa; }
  .setup h3 { margin-top:0; }
  textarea { width:100%; min-height:100px; padding:10px; border:1px solid #ddd; border-radius:10px; font-size:14px; }
  .setupGrid { display:flex; gap:12px; flex-wrap:wrap; }
  .setupCol { flex:1 1 240px; }

  /* On-court horizontal row */
  #oncourtColumn {
    display:flex;
    flex-direction:row;
    flex-wrap:nowrap;
    gap:12px;
    overflow-x:auto;
    padding-bottom:6px;
  }
  .card {
    border: 1px solid #e5e5e5; border-radius: 14px; padding: 10px;
    width: clamp(190px, 24vw, 240px);
    aspect-ratio: 1 / 1;
    flex: 0 0 auto;
    display:flex; flex-direction:column; gap:12px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.03);
  }
  .nameRow { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .name { font-weight: 850; font-size: 22px; }
  .inlineStats { font-size:18px; color:#333; font-weight:700; }

  /* Action buttons: Gave/High | Got */
  .btn { padding:22px; border:none; border-radius:14px; cursor:pointer; font-size:22px; font-weight:800; width:100%; }
  .btn:active { transform: scale(0.98); }
  .btn-tag { background:#e8f7ee; }
  .btn-tag.btn-primary { padding:26px; font-size:24px; }
  .btn-high { background:#f2f2f2; }
  .btn-defl { background:#eef2ff; border-radius:14px; }
  .btn-miss { background:#f2f2f2; }
  .bar2 {
    display:grid;
    grid-template-columns: 1.2fr 0.8fr;
    gap:14px;
    align-items:stretch;
  }
  .actionStack {
    display:grid;
    grid-template-rows: 1fr 1fr;
    gap:12px;
  }
  .actionStackRight {
    display:grid;
    grid-template-rows: 1fr auto;
    gap:12px;
  }
  .btn-smaction {
    padding:10px;
    font-size:16px;
    border-radius:12px;
  }
  .btn-slim {
    padding:16px;
    font-size:20px;
  }

  /* Quick-sub prompt */
  .prompt { font-size:14px; color:#444; margin: 4px 0 8px; }

  /* Bench dock */
  .benchDockWrap { margin-top: 14px; }
  .dockTitle { font-weight:700; margin-bottom:6px; }
  .benchDock {
    display:flex;
    gap:12px;
    overflow-x:auto;
    padding:12px;
    border:1px solid #eee;
    border-radius:12px;
    background:#fafafa;
  }
  .bench-card { background:#fff; cursor:pointer; }
  .bench-card:active { transform: scale(0.98); }
  .benchNote { font-size:12px; color:#666; margin-top:auto; }
  .coachDockWrap { margin-top: 10px; }
  .coachDock { display:flex; gap:12px; overflow-x:auto; padding:12px; border:1px solid #eee; border-radius:12px; background:#fafafa; }
  .coach-card { background:#fff; }

  .divider { height:1px; background:#eee; margin:12px 0; }

  /* Totals */
  .totals h2 { margin-top: 14px; }
  .totalsTable { width:100%; border-collapse: collapse; }
  .totalsTable thead th {
    text-align:left; font-size:16px; color:#555; padding:6px 4px;
    border-bottom:1px solid #eee;
  }
  .totalsTable tbody td {
    padding:10px 4px; font-size:18px; font-weight:700; border-bottom:1px dashed #f0f0f0;
  }
  .totalsName { font-weight:900; }

  /* Bottom controls */
  .controls-bottom { margin-top: 16px; display:flex; gap:10px; flex-wrap:wrap; }
</style>
</head>
<body>

<div class="topbar">
  <div class="spacer"></div>
  <span id="saveState" class="muted">Saved</span>
</div>

<div class="setup" id="setupPanel">
  <div class="setupGrid">
    <div class="setupCol">
      <h3>Roster (one name per line)</h3>
      <textarea id="rosterInput" placeholder="Karisma&#10;Maya D&#10;Ava&#10;Diana&#10;Jojo"></textarea>
    </div>
    <div class="setupCol">
      <h3>Coaches (one name per line)</h3>
      <textarea id="coachesInput" placeholder="Coach A&#10;Coach B"></textarea>
    </div>
  </div>
  <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
    <button class="btn-sm" onclick="saveRoster()">Save Roster</button>
    <button class="btn-sm" onclick="saveCoaches()">Save Coaches</button>
    <button class="btn-sm" onclick="startGame()">Start Game (First 5 active)</button>
    <button class="btn-sm" onclick="exportCSV()">Export CSV</button>
    <button class="btn-sm" onclick="resetGame()">Reset Game</button>
  </div>
  <div class="muted" style="margin-top:6px;">Everything is stored locally on this device. No internet required.</div>
</div>

<!-- Quick-sub prompt -->
<div id="qsPrompt" class="prompt" style="display:none;"></div>

<h2>On Court</h2>
<div id="oncourtColumn"></div>
<div class="topbar" style="margin-top:10px;">
  <button id="undoBtn" class="btn-md" onclick="undoLast()">Undo</button>
  <button id="redoBtn" class="btn-md" onclick="redoLast()">Redo</button>
  <button id="allTaggedBtn" class="btn-md btn-huddle" onclick="allTagged()">Huddle</button>
</div>

<!-- Bench dock -->
<div class="benchDockWrap">
  <div class="dockTitle">Bench (tap a name, then tap who comes OUT)</div>
  <div id="benchDock" class="benchDock"></div>
</div>
<div class="coachDockWrap">
  <div class="dockTitle">Coaches</div>
  <div id="coachDock" class="coachDock"></div>
</div>

<div class="divider"></div>

<!-- Totals -->
<div class="totals">
  <h2>Totals</h2>
  <table class="totalsTable">
    <thead>
      <tr>
        <th>Player</th>
        <th>Touches</th>
        <th>High</th>
        <th>Sm</th>
      </tr>
    </thead>
    <tbody id="totalsBody"></tbody>
  </table>
  <h2>Coach Totals</h2>
  <table class="totalsTable">
    <thead>
      <tr>
        <th>Coach</th>
        <th>Touches</th>
        <th>High</th>
        <th>Sm</th>
      </tr>
    </thead>
    <tbody id="coachTotalsBody"></tbody>
  </table>
</div>

<div class="controls-bottom">
  <button class="btn-sm" onclick="exportCSV()">Export CSV</button>
  <button class="btn-sm" onclick="resetGame()">Reset Game</button>
</div>

<script>
  // ------- Local data (localStorage) -------
  const KEY = 'edge_local_stat_tracker_v1';

  const defaultState = () => ({
    roster: [],                       // array of names
    players: {},                      // name -> {tags, misses, sm, defl, active}
    coaches: [],                      // array of coach names
    coachStats: {},                   // name -> {tags, misses, sm}
    huddles: 0,                       // team huddle count
    history: [],                      // undo stack (array of events)
    future: [],                       // redo stack
    log: []                           // full event log for CSV
  });

  let S = load();

  function load() {
    try {
      const raw = localStorage.getItem(KEY);
      if (!raw) return defaultState();
      const obj = JSON.parse(raw);
      // basic sanity
      obj.roster ||= [];
      obj.players ||= {};
      obj.coaches ||= [];
      obj.coachStats ||= {};
      obj.huddles ||= 0;
      obj.history ||= [];
      obj.future ||= [];
      obj.log ||= [];
      return obj;
    } catch (_) { return defaultState(); }
  }

  function persist() {
    localStorage.setItem(KEY, JSON.stringify(S));
    markSaved();
  }

  let saveTimer = null;
  function markDirty() {
    clearTimeout(saveTimer);
    const el = document.getElementById('saveState');
    el.textContent = 'Saving…';
    saveTimer = setTimeout(()=>{ el.textContent = 'Saved'; }, 400);
  }
  function markSaved() {
    const el = document.getElementById('saveState');
    el.textContent = 'Saved';
  }

  // ------- Setup actions -------
  function saveRoster() {
    const txt = document.getElementById('rosterInput').value || '';
    const names = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const seen = new Set();
    const uniq = names.filter(n => { if (seen.has(n)) return false; seen.add(n); return true; });

    // carry over existing stats if name already there
    const players = {};
    uniq.forEach(n => {
      const prev = S.players[n];
      players[n] = prev ? {...prev} : { tags:0, misses:0, sm:0, defl:0, active:false };
    });

    S.roster = uniq;
    S.players = players;
    S.history = [];
    S.future = [];
    markDirty(); persist(); render();
  }

  function saveCoaches() {
    const txt = document.getElementById('coachesInput').value || '';
    const names = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const seen = new Set();
    const uniq = names.filter(n => { if (seen.has(n)) return false; seen.add(n); return true; });

    const stats = {};
    uniq.forEach(n => {
      const prev = S.coachStats[n];
      stats[n] = prev ? {...prev} : { tags:0, misses:0, sm:0 };
    });

    S.coaches = uniq;
    S.coachStats = stats;
    S.history = [];
    S.future = [];
    markDirty(); persist(); render();
  }

  function startGame() {
    if (S.roster.length === 0) saveRoster();
    // set first 5 active, others bench
    S.roster.forEach((n,i)=> { S.players[n].active = i < 5; });
    S.history = [];
    S.future = [];
    markDirty(); persist(); render();
  }

  function resetGame() {
    if (!confirm('Reset tags/misses/deflections and clear the court?')) return;
    Object.values(S.players).forEach(p => { p.tags=0; p.misses=0; p.sm=0; p.defl=0; p.active=false; });
    Object.values(S.coachStats).forEach(p => { p.tags=0; p.misses=0; p.sm=0; });
    S.huddles = 0;
    S.history = [];
    S.future = [];
    S.log = [];
    markDirty(); persist(); render();
  }

  // ------- Rendering -------
  let subMode = null; // {inName}

  function render() {
    // Prefill roster textarea if empty
    const ta = document.getElementById('rosterInput');
    if (!ta.value && S.roster.length) ta.value = S.roster.join('\n');
    const ca = document.getElementById('coachesInput');
    if (!ca.value && S.coaches.length) ca.value = S.coaches.join('\n');

    // Undo/redo buttons
    document.getElementById('undoBtn').classList.toggle('btn-disabled', S.history.length === 0);
    document.getElementById('redoBtn').classList.toggle('btn-disabled', S.future.length === 0);


    // Quick-sub prompt
    const prompt = document.getElementById('qsPrompt');
    if (subMode) {
      prompt.style.display = '';
      prompt.textContent = `Quick Sub: tap who comes OUT for ${subMode.inName}`;
    } else {
      prompt.style.display = 'none';
      prompt.textContent = '';
    }

    // Build on-court and bench lists
    const onCourt = S.roster.filter(n => S.players[n]?.active);
    const bench = S.roster.filter(n => !S.players[n]?.active);

    // On court
    const col = document.getElementById('oncourtColumn');
    col.innerHTML = '';
    onCourt.forEach(name => {
      const p = S.players[name];
      const tagBtn  = button('btn btn-tag btn-primary', '1', (e)=>{ e.stopPropagation(); doDelta(name,'tags',+1); });
      const highBtn = button('btn btn-high', 'High', (e)=>{ e.stopPropagation(); doDelta(name,'tags',+2); doDelta(name,'misses',+1); });
      const missBtn = button('btn btn-miss btn-slim', '2', (e)=>{ e.stopPropagation(); doDelta(name,'tags',+2); });
      const smBtn   = button('btn btn-miss btn-smaction btn-slim', 'sm', (e)=>{ e.stopPropagation(); doDelta(name,'sm',+1); });
      const card = div('card', {
        onclick: ()=> maybeCompleteQuickSubOut(name)
      }, [
        div('nameRow', {}, [
          div('name', {}, name),
          div('inlineStats', {}, `· ${p.tags} Touches | ${p.misses} High`)
        ]),
        div('bar2', {}, [div('actionStack', {}, [tagBtn, highBtn]), div('actionStackRight', {}, [missBtn, smBtn])])
      ]);
      col.appendChild(card);
    });

    // Bench chips
    const dock = document.getElementById('benchDock');
    dock.innerHTML = '';
    bench.forEach(name => {
      const p = S.players[name];
      const tagBtn  = button('btn btn-tag btn-primary', '1', (e)=>{ e.stopPropagation(); doDelta(name,'tags',+1); });
      const highBtn = button('btn btn-high', 'High', (e)=>{ e.stopPropagation(); doDelta(name,'tags',+2); doDelta(name,'misses',+1); });
      const missBtn = button('btn btn-miss btn-slim', '2', (e)=>{ e.stopPropagation(); doDelta(name,'tags',+2); });
      const smBtn   = button('btn btn-miss btn-smaction btn-slim', 'sm', (e)=>{ e.stopPropagation(); doDelta(name,'sm',+1); });
      const card = div('card bench-card', { onclick: ()=>quickSubStart(name) }, [
        div('nameRow', {}, [
          div('name', {}, name),
          div('inlineStats', {}, `· ${p.tags} Touches | ${p.misses} High`)
        ]),
        div('bar2', {}, [div('actionStack', {}, [tagBtn, highBtn]), div('actionStackRight', {}, [missBtn, smBtn])]),
        div('benchNote', {}, 'Tap card to sub in')
      ]);
      dock.appendChild(card);
    });

    // Coaches row
    const coachDock = document.getElementById('coachDock');
    coachDock.innerHTML = '';
    S.coaches.forEach(name => {
      const p = S.coachStats[name] || { tags:0, misses:0, sm:0 };
      const tagBtn  = button('btn btn-tag btn-primary', '1', (e)=>{ e.stopPropagation(); doCoachDelta(name,'tags',+1); });
      const highBtn = button('btn btn-high', 'High', (e)=>{ e.stopPropagation(); doCoachDelta(name,'tags',+2); doCoachDelta(name,'misses',+1); });
      const missBtn = button('btn btn-miss btn-slim', '2', (e)=>{ e.stopPropagation(); doCoachDelta(name,'tags',+2); });
      const smBtn   = button('btn btn-miss btn-smaction btn-slim', 'sm', (e)=>{ e.stopPropagation(); doCoachDelta(name,'sm',+1); });
      const card = div('card coach-card', {}, [
        div('nameRow', {}, [
          div('name', {}, name),
          div('inlineStats', {}, `· ${p.tags} Touches | ${p.misses} High`)
        ]),
        div('bar2', {}, [div('actionStack', {}, [tagBtn, highBtn]), div('actionStackRight', {}, [missBtn, smBtn])])
      ]);
      coachDock.appendChild(card);
    });

    // Totals table (sorted by tags desc)
    const body = document.getElementById('totalsBody');
    body.innerHTML = '';
    const rows = S.roster.map(name => {
      const p = S.players[name] || {tags:0,misses:0,sm:0,defl:0};
      const touches = p.tags||0, high = p.misses||0, sm = p.sm||0;
      return { name, touches, high, sm };
    }).sort((a,b)=> b.touches - a.touches);

    rows.forEach(r => {
      body.appendChild(tr([
        td('totalsName', r.name),
        td('', String(r.touches)),
        td('', String(r.high)),
        td('', String(r.sm)),
      ]));
    });
    const totalsTouches = rows.reduce((sum, r) => sum + r.touches, 0);
    const totalsHigh = rows.reduce((sum, r) => sum + r.high, 0);
    const totalsSm = rows.reduce((sum, r) => sum + r.sm, 0);
    body.appendChild(tr([
      td('totalsName', 'Player Totals'),
      td('', String(totalsTouches)),
      td('', String(totalsHigh)),
      td('', String(totalsSm)),
    ]));
    body.appendChild(tr([
      td('totalsName', 'Team Huddles'),
      td('', String(S.huddles || 0)),
      td('', ''),
      td('', ''),
    ]));

    const coachBody = document.getElementById('coachTotalsBody');
    coachBody.innerHTML = '';
    const coachRows = S.coaches.map(name => {
      const p = S.coachStats[name] || { tags:0, misses:0, sm:0 };
      return { name, touches: p.tags || 0, high: p.misses || 0, sm: p.sm || 0 };
    }).sort((a,b)=> b.touches - a.touches);
    coachRows.forEach(r => {
      coachBody.appendChild(tr([
        td('totalsName', r.name),
        td('', String(r.touches)),
        td('', String(r.high)),
        td('', String(r.sm)),
      ]));
    });
    const coachTotalsTouches = coachRows.reduce((sum, r) => sum + r.touches, 0);
    const coachTotalsHigh = coachRows.reduce((sum, r) => sum + r.high, 0);
    const coachTotalsSm = coachRows.reduce((sum, r) => sum + r.sm, 0);
    coachBody.appendChild(tr([
      td('totalsName', 'Team Totals'),
      td('', String(totalsTouches + coachTotalsTouches)),
      td('', String(totalsHigh + coachTotalsHigh)),
      td('', String(totalsSm + coachTotalsSm)),
    ]));
  }

  // ------- Actions & history (undo/redo) -------
  function doDelta(name, field, delta) {
    const p = S.players[name]; if (!p) return;
    // apply
    p[field] = Math.max(0, (Number(p[field])||0) + delta);
    // log & history
    const ev = { t:'delta', name, field, delta, ts: Date.now() };
    S.history.push(ev);
    S.future = [];
    S.log.push(ev);
    markDirty(); persist(); render();
  }

  function doCoachDelta(name, field, delta) {
    const p = S.coachStats[name]; if (!p) return;
    p[field] = Math.max(0, (Number(p[field])||0) + delta);
    const ev = { t:'coach_delta', name, field, delta, ts: Date.now() };
    S.history.push(ev);
    S.future = [];
    S.log.push(ev);
    markDirty(); persist(); render();
  }

  function allTagged() {
    const active = S.roster.filter(n => S.players[n]?.active);
    if (active.length === 0) return;
    active.forEach(name => {
      const p = S.players[name];
      if (p) p.tags = Math.max(0, (Number(p.tags) || 0) + 1);
    });
    S.huddles = (S.huddles || 0) + 1;
    const ev = { t:'huddle', active, ts: Date.now() };
    S.history.push(ev);
    S.future = [];
    S.log.push(ev);
    markDirty(); persist(); render();
  }


  function quickSubStart(inName) { subMode = { inName }; render(); }

  function maybeCompleteQuickSubOut(outName) {
    if (!subMode) return;
    doSub(outName, subMode.inName);
    subMode = null;
  }

  function doSub(outName, inName) {
    if (outName === inName) return;
    const outP = S.players[outName], inP = S.players[inName];
    if (!outP || !inP) return;
    outP.active = false; inP.active = true;

    const ev = { t:'sub', out: outName, in: inName, ts: Date.now() };
    S.history.push(ev);
    S.future = [];
    S.log.push(ev);
    markDirty(); persist(); render();
  }

  function undoLast() {
    if (S.history.length === 0) return;
    const ev = S.history.pop();
    let inv = null;
    if (ev.t === 'delta') {
      inv = { ...ev, delta: -ev.delta, ts: Date.now() };
      const p = S.players[ev.name];
      if (p) p[ev.field] = Math.max(0, (Number(p[ev.field])||0) - ev.delta);
    } else if (ev.t === 'coach_delta') {
      inv = { ...ev, delta: -ev.delta, ts: Date.now() };
      const p = S.coachStats[ev.name];
      if (p) p[ev.field] = Math.max(0, (Number(p[ev.field])||0) - ev.delta);
    } else if (ev.t === 'sub') {
      inv = { t:'sub', out: ev.in, in: ev.out, ts: Date.now() };
      const outP = S.players[ev.in], inP = S.players[ev.out];
      if (outP && inP) { outP.active=false; inP.active=true; }
    } else if (ev.t === 'huddle') {
      inv = { t:'huddle', active: ev.active || [], ts: Date.now() };
      (ev.active || []).forEach(name => {
        const p = S.players[name];
        if (p) p.tags = Math.max(0, (Number(p.tags) || 0) - 1);
      });
      S.huddles = Math.max(0, (S.huddles || 0) - 1);
    }
    if (inv) {
      S.future.push(ev);
      S.log.push({ t:'undo', of:ev, ts: Date.now() });
      markDirty(); persist(); render();
    }
  }

  function redoLast() {
    if (S.future.length === 0) return;
    const ev = S.future.pop();
    if (ev.t === 'delta') {
      const p = S.players[ev.name]; if (p) p[ev.field] = Math.max(0, (Number(p[ev.field])||0) + ev.delta);
    } else if (ev.t === 'coach_delta') {
      const p = S.coachStats[ev.name]; if (p) p[ev.field] = Math.max(0, (Number(p[ev.field])||0) + ev.delta);
    } else if (ev.t === 'sub') {
      const outP = S.players[ev.out], inP = S.players[ev.in];
      if (outP && inP) { outP.active=false; inP.active=true; }
    } else if (ev.t === 'huddle') {
      (ev.active || []).forEach(name => {
        const p = S.players[name];
        if (p) p.tags = Math.max(0, (Number(p.tags) || 0) + 1);
      });
      S.huddles = (S.huddles || 0) + 1;
    }
    S.history.push(ev);
    S.log.push({ t:'redo', of:ev, ts: Date.now() });
    markDirty(); persist(); render();
  }

  // ------- CSV Export -------
  function exportCSV() {
    // Build a minimal event log CSV and a summary CSV in one file
    const header1 = 'type,name,field,delta,out,in,timestamp\n';
    const rows1 = S.log.map(ev => {
      if (ev.t === 'delta') return `delta,${csv(ev.name)},${ev.field},${ev.delta},,,${ev.ts}`;
      if (ev.t === 'sub')   return `sub,,,,${csv(ev.out)},${csv(ev.in)},${ev.ts}`;
      if (ev.t === 'undo')  return `undo,,,,,,${ev.ts}`;
      if (ev.t === 'redo')  return `redo,,,,,,${ev.ts}`;
      return '';
    }).filter(Boolean).join('\n');

    const header2 = '\n\nplayer,touches,high,sm\n';
    const rows2 = S.roster.map(name => {
      const p = S.players[name] || {tags:0,misses:0,sm:0,defl:0};
      return `${csv(name)},${p.tags||0},${p.misses||0},${p.sm||0}`;
    }).join('\n');

    const csvText = header1 + rows1 + header2 + rows2 + '\n';
    const blob = new Blob([csvText], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const now = new Date().toISOString().replace(/[:T]/g,'-').slice(0,16);
    a.href = url; a.download = `tagging_stats_${now}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }

  function csv(s) { return (''+s).replaceAll('"','""'); }

  // ------- tiny DOM helpers -------
  function el(tag, attrs={}, children=[]) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v]) => (k in e) ? e[k]=v : e.setAttribute(k,v));
    (Array.isArray(children)?children:[children]).forEach(c => {
      if (typeof c === 'string') e.appendChild(document.createTextNode(c));
      else if (c) e.appendChild(c);
    });
    return e;
  }
  const div = (cls, attrs={}, children=[]) => {
    if (typeof attrs === 'string' || Array.isArray(attrs)) { children = attrs; attrs = {}; }
    return el('div', Object.assign({className:cls}, attrs), children);
  };
  const button = (cls, text, onclick) => {
    const b = el('button', { className: cls }, [text]);
    if (onclick) b.addEventListener('click', onclick);
    return b;
  };
  const td = (cls, text) => {
    const c = el('td', {}, [text]);
    if (cls) c.className = cls;
    return c;
  };
  const tr = (cells) => {
    const row = el('tr');
    cells.forEach(c => row.appendChild(c));
    return row;
  };

  // ------- boot -------
  render();
</script>
</body>
</html>
